from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Depends, Response
from sqlmodel import select
from src.api.core.operation import updateOp
from src.api.core.response import raiseExceptions
from src.api.core.smtp import send_email
from src.api.core.utility import Print
from src.config import ACCESS_TOKEN_EXPIRE_MINUTES, DOMAIN
from src.api.core.security import (
    create_access_token,
    decode_token,
    exist_user,
    hash_password,
    verify_password,
    verify_refresh_token,
)
from sqlalchemy.orm import selectinload, joinedload
from src.api.models.roleModel import Role
from src.api.models.userModel import (
    UpdateUserByAdmin,
    UserCreate,
    User,
    UserRead,
    LoginRequest,
)
from src.api.core import (
    GetSession,
    api_response,
    requireSignin,
    requireAdmin,
    requirePermission,
)

router = APIRouter(tags=["Auth"])


@router.post("/init", response_model=UserRead)
def initialize_first_user(
    request: UserCreate,
    session: GetSession,
):

    # Prevent rerun if roles already exist
    existing_roles = session.exec(select(Role)).all()
    if existing_roles:
        return api_response(
            400,
            "Initialization already done",
        )

    # Create roles
    admin_role = Role(
        title="root",
        permissions=["all", "system:*"],
    )

    session.add(admin_role)
    session.flush()  # get IDs without committing

    # Create first user with admin role
    hashed_password = hash_password(request.password)
    user = User(**request.model_dump())
    user.password = hashed_password
    user.verified = True
    user.email_verified = True
    user.is_root = True
    user.role_id = admin_role.id
    session.add(user)
    session.flush()

    session.commit()
    session.refresh(user)

    user_read = UserRead.model_validate(user)
    return api_response(
        200,
        "Initialized admin user and roles",
        user_read,
    )


def exist_verified_user(session, phone: str):
    """Return verified user with same phone if exists"""
    return session.exec(
        select(User).where(User.phone == phone, User.verified == True)
    ).first()


@router.post("/register", response_model=UserRead)
def register_user(
    request: UserCreate,
    session: GetSession,
):
    verified_user = exist_verified_user(session, request.phone)
    if verified_user:
        return api_response(
            400, "This phone number is already registered and verified."
        )

    db_user = exist_user(session, email=request.email)
    if db_user:
        return api_response(
            400,
            "This user already exist",
        )
    if request.phone is None:
        return api_response(
            400,
            "Phone number is required",
        )
    user = User(**request.model_dump())  # Similar to new User(req.body) in Mongoose
    user.unverified_phone = request.phone
    user.phone = None
    hashed_password = hash_password(user.password)
    user.password = hashed_password
    session.add(user)
    session.commit()
    session.refresh(user)  # Refresh to get updated fields (e.g., autogenerated ID)

    # ✅ Create JWT token (valid for lifetime)
    token = create_access_token({"id": user.id, "email": user.email})

    verify_url = f"{DOMAIN}/api/verify-email?token={token}"
    # Load template
    with open("src/templates/email_verification.html") as f:
        html_template = f.read().replace("{{VERIFY_URL}}", verify_url)

    # Send email
    send_email(
        to_email=user.email,
        subject="Verify Your Email Address",
        body=html_template,
    )
    user_read = UserRead.model_validate(user)  # ✅ Convert User → UserRead
    return api_response(
        200,
        "Check Your Email to Verify Your Account",
        user_read,
    )


@router.get("/verify-email")
def verify_email(token: str, session: GetSession):
    decode = decode_token(token)
    if not decode:
        return api_response(400, "Invalid or expired verification token")

    user_data = decode.get("user")
    if not user_data:
        return api_response(400, "Invalid token payload")

    user = session.exec(select(User).where(User.email == user_data["email"])).first()

    if not user:
        return api_response(400, "Invalid or expired verification token")

    user.email_verified = True

    session.add(user)
    session.commit()
    session.refresh(user)

    return api_response(200, "Email verified successfully!")


@router.post("/login", response_model=dict)
def login_user(
    request: LoginRequest,
    response: Response,
    session: GetSession,
):

    # Detect email or phone
    identifier = request.identifier.strip()

    if "@" in identifier:
        user = session.exec(
            select(User)
            .options(selectinload(User.role))
            .where(User.email == identifier)
        ).first()
    else:
        user = session.exec(
            select(User)
            .options(selectinload(User.role))
            .where(User.phone == identifier)
        ).first()

    if not user:
        return api_response(400, "User not found")

    # If email login → must be verified
    if "@" in identifier and not user.email_verified:
        return api_response(401, "Please verify your email before logging in")

    user_read = UserRead.model_validate(user)

    if not verify_password(request.password, user.password):
        return api_response(401, "Incorrect password")
    if not user.is_active:
        return api_response(403, "User account is disabled")

    # Use properties instead of user.roles
    user_dict = user_read.model_dump()
    role = user_dict["role"]

    user_data = {
        "id": user.id,
        "email": user.email,
        "phone": user.phone or None,
        "is_root": user.is_root or False,
        "role": role,
        "verified": user.verified or False,
    }
    # Print(user_data)
    access_token = create_access_token(user_data=user_data)
    refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )
    # cookie will test in postman and frontend only with tag credential:true
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )
    content = {
        "message": "Login successful",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": user_read,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "Login successful", content)


@router.put("/update_by_admin", response_model=UserRead)
def update_user(
    user: requireAdmin,
    request: UpdateUserByAdmin,
    session: GetSession,
):
    user_id = user.get("id")
    db_user = session.get(User, user_id)  # Like findById
    raiseExceptions((db_user, 404, "User not found"))
    updated_user = updateOp(db_user, request, session)
    # ✅ Handle password hash only if password provided
    if request.password:
        updated_user.password = hash_password(request.password)

    session.commit()
    session.refresh(db_user)
    return api_response(200, "User Found", UserRead.model_validate(db_user))


@router.post(
    "/refresh",
)
def refresh_token(
    refresh_token: str,
):
    if not refresh_token:
        api_response(401, "Missing refresh token")

    payload = verify_refresh_token(refresh_token)
    if not payload:
        raise api_response(401, "Invalid refresh token")
    user = decode_token(refresh_token)
    # user = UserRead.model_validate(db_user)
    access_token = create_access_token(user)
    new_refresh_token = create_access_token(user_data=user, refresh=True)

    return api_response(
        200,
        "Refresh",
        {
            "access_token": access_token,
            "refresh_token": new_refresh_token,
            "user": user,
        },
    )


@router.post("/logout")
def logout(response: Response):
    response.delete_cookie("refresh_token")
    response.delete_cookie("access_token")
    return {"message": "Logged out"}


@router.get("/testauth", response_model=dict)
def test_auth(
    user: requireSignin,
):
    return api_response(
        200,
        "Token is valid",
        {"user": user},
    )


@router.get("/testadmin")
def get_admin_data(
    user: requireAdmin,
):

    return {"message": f"Hello Admin {user['phone']}", "user": user}


@router.get("/testpermission")
def get_admin_data(
    user=requirePermission("system:*"),
):
    return api_response(200, "Root Access Granted", {"user": user})

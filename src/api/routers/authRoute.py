from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Response
from sqlmodel import select
from src.config import ACCESS_TOKEN_EXPIRE_MINUTES
from src.api.core.security import (
    create_access_token,
    exist_user,
    hash_password,
    verify_password,
)
from sqlalchemy.orm import selectinload
from src.api.models.roleModel import Role
from src.api.models.userModel import UserCreate, User, UserRead, LoginRequest, UserRole
from src.api.core import (
    GetSession,
    api_response,
    requireSignin,
    requireAdmin,
    requirePermission,
)

router = APIRouter(tags=["Auth"])


@router.post("/init", response_model=UserRead)
def initialize_first_user(
    request: UserCreate,
    session: GetSession,
):

    # Prevent rerun if roles already exist
    existing_roles = session.exec(select(Role)).all()
    if existing_roles:
        return api_response(
            400,
            "Initialization already done",
        )

    # Create roles
    admin_role = Role(
        title="root",
        permissions=["all", "system:*"],
    )

    session.add(admin_role)
    session.flush()  # get IDs without committing

    # Create first user with admin role
    hashed_password = hash_password(request.password)
    user = User(**request.model_dump())
    user.password = hashed_password
    user.verified = True
    user.is_root = True
    user.role_id = admin_role.id
    print(user)
    session.add(user)
    session.flush()

    session.commit()
    session.refresh(user)

    user_read = UserRead.model_validate(user)
    return api_response(
        200,
        "Initialized admin user and roles",
        user_read,
    )


def exist_verified_user(session, phone: str):
    """Return verified user with same phone if exists"""
    return session.exec(
        select(User).where(User.phone == phone, User.verified == True)
    ).first()


@router.post("/register", response_model=UserRead)
def register_user(
    request: UserCreate,
    session: GetSession,
):
    verified_user = exist_verified_user(session, request.phone)
    if verified_user:
        return api_response(
            400, "This phone number is already registered and verified."
        )

    db_user = exist_user(session, email=request.email)
    if db_user:
        return api_response(
            400,
            "This user already exist",
        )
    user = User(**request.model_dump())  # Similar to new User(req.body) in Mongoose
    hashed_password = hash_password(user.password)
    user.password = hashed_password
    session.add(user)
    session.commit()
    session.refresh(user)  # Refresh to get updated fields (e.g., autogenerated ID)
    user_read = UserRead.model_validate(user)  # ✅ Convert User → UserRead
    return api_response(
        200,
        "User Registered Successfully",
        user_read,
    )


@router.post("/login", response_model=dict)
def login_user(
    request: LoginRequest,
    response: Response,
    session: GetSession,
):

    user = session.exec(
        select(User).options(selectinload(User.role)).where(User.phone == request.phone)
    ).first()
    print(user)
    return api_response(200, "Login successful", user)
    if not user:
        return api_response(404, "User not found")
    if not verify_password(request.password, user.password):
        return api_response(401, "Incorrect password")
    # if not user.is_active:
    #     return api_response(403, "User account is disabled")

    # Use properties instead of user.roles
    role = user.role

    user_data = {
        "id": user.id,
        "phone": user.phone,
        "is_root": user.is_root or False,
        "role": role,
        "verified": user.verified or False,
    }
    # Print(user_data)
    access_token = create_access_token(user_data=user_data)
    refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )

    # user_read = UserRead.model_validate(user)
    # cookie will test in postman and frontend only with tag credential:true
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )
    content = {
        "message": "Login successful",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": user,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "Login successful", content)

from datetime import datetime, timedelta, timezone
from random import randint
from fastapi import APIRouter, Depends, Response
from sqlmodel import delete, select
from src.api.core.operation import updateOp
from src.api.core.response import raiseExceptions
from src.api.core.smtp import send_email
from src.config import ACCESS_TOKEN_EXPIRE_MINUTES, DOMAIN
from src.api.core.security import (
    create_access_token,
    decode_token,
    exist_user,
    hash_password,
    verify_password,
    verify_refresh_token,
)
from sqlalchemy.orm import selectinload, joinedload
from src.api.models.roleModel import Role
from src.api.models.userModel import (
    EmailRequest,
    ResetPasswordWithOTPRequest,
    UserCreate,
    User,
    UserRead,
    LoginRequest,
    updateEmail,
)
from src.api.core import (
    GetSession,
    api_response,
    requireSignin,
    requireAdmin,
    requirePermission,
)

router = APIRouter(tags=["Auth"])


@router.post("/init", response_model=UserRead)
def initialize_first_user(
    request: UserCreate,
    session: GetSession,
):

    # Prevent rerun if roles already exist
    existing_roles = session.exec(select(Role)).all()
    if existing_roles:
        return api_response(
            400,
            "Initialization already done",
        )

    # Create roles
    admin_role = Role(
        title="root",
        permissions=["all", "system:*"],
    )

    session.add(admin_role)
    session.flush()  # get IDs without committing

    # Create first user with admin role
    hashed_password = hash_password(request.password)
    user = User(**request.model_dump())
    user.password = hashed_password
    user.verified = True
    user.email_verified = True
    user.is_root = True
    user.role_id = admin_role.id
    session.add(user)
    session.flush()

    session.commit()
    session.refresh(user)

    user_read = UserRead.model_validate(user)
    return api_response(
        200,
        "Initialized admin user and roles",
        user_read,
    )


def exist_verified_user(session, phone: str):
    """Return verified user with same phone if exists"""
    return session.exec(
        select(User).where(User.phone == phone, User.verified == True)
    ).first()


def exist_verified_email(session, email: str) -> bool:

    user = session.exec(
        select(User.id).where(
            User.email == email,
            User.email_verified == True,
        )
    ).first()
    print({"user===========": user})
    print(email)
    return True if user else False


@router.post("/register", response_model=UserRead)
def register_user(
    request: UserCreate,
    session: GetSession,
):
    verified_user = exist_verified_user(session, request.phone)
    if verified_user:
        return api_response(
            400, "This phone number is already registered and verified."
        )

    # ‚ùå Block if email is already verified
    if exist_verified_email(session, request.email):
        return api_response(
            400,
            "This email is already registered and verified.",
        )
    if request.phone is None:
        return api_response(
            400,
            "Phone number is required",
        )
    user = User(**request.model_dump())  # Similar to new User(req.body) in Mongoose
    user.unverified_phone = request.phone
    user.phone = None
    hashed_password = hash_password(user.password)
    user.password = hashed_password
    session.add(user)
    session.commit()
    session.refresh(user)  # Refresh to get updated fields (e.g., autogenerated ID)

    # ‚úÖ Create JWT token (valid for lifetime)
    token = create_access_token({"id": user.id, "email": user.email})

    verify_url = f"{DOMAIN}/verify/verify-email?token={token}"
    # Load template
    with open("src/templates/email_verification.html") as f:
        html_template = f.read().replace("{{VERIFY_URL}}", verify_url)

    # Send email
    send_email(
        to_email=user.email,
        subject="Verify Your Email Address",
        body=html_template,
    )
    user_read = UserRead.model_validate(user)  # ‚úÖ Convert User ‚Üí UserRead
    return api_response(
        200,
        "Check Your Email to Verify Your Account",
        user_read,
    )


@router.post("/login", response_model=dict)
def login_user(
    request: LoginRequest,
    response: Response,
    session: GetSession,
):

    # Detect email or phone
    identifier = request.identifier.strip()

    if "@" in identifier:
        user = session.exec(
            select(User)
            .options(selectinload(User.role))
            .where(User.email == identifier)
        ).first()
    else:
        user = session.exec(
            select(User)
            .options(selectinload(User.role))
            .where(User.phone == identifier)
        ).first()

    if not user:
        return api_response(400, "User not found")

    # If email login ‚Üí must be verified
    if "@" in identifier and not user.email_verified:
        return api_response(401, "Please verify your email before logging in")

    user_read = UserRead.model_validate(user)

    if not verify_password(request.password, user.password):
        return api_response(401, "Incorrect password")
    if not user.is_active:
        return api_response(403, "User account is disabled")

    # Use properties instead of user.roles
    user_dict = user_read.model_dump()
    role = user_dict["role"]

    user_data = {
        "id": user.id,
        "email": user.email,
        "phone": user.phone or None,
        "is_root": user.is_root or False,
        "role": role,
        "verified": user.verified or False,
    }
    # Print(user_data)
    access_token = create_access_token(user_data=user_data)
    refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )
    # cookie will test in postman and frontend only with tag credential:true
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )
    content = {
        "message": "Login successful",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": user_read,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "Login successful", content)


@router.post("/update-email")
def update_email(
    request: updateEmail,
    session: GetSession,
):
    email = request.email.strip()
    user = session.exec(
        select(User).options(selectinload(User.role)).where(User.email == email)
    ).first()
    if not user:
        return api_response(400, "User not found")

    if request.updateEmail != user.email and exist_verified_email(
        session, request.updateEmail
    ):
        return api_response(
            400,
            "This email is already registered and verified.",
        )
    user.email = request.updateEmail
    user.email_verified = False

    token = create_access_token({"id": user.id, "email": user.email})

    verify_url = f"{DOMAIN}/api/verify-email?token={token}"
    with open("src/templates/email_verification.html") as f:
        html_template = f.read().replace("{{VERIFY_URL}}", verify_url)

    # Send email
    send_email(
        to_email=user.email,
        subject="Verify Your Email Address",
        body=html_template,
    )

    session.add(user)
    session.commit()
    session.refresh(user)

    return api_response(
        200, "User Email Updated , Verify Your Email", UserRead.model_validate(user)
    )


@router.post(
    "/refresh",
)
def refresh_token(
    refresh_token: str,
):
    if not refresh_token:
        api_response(401, "Missing refresh token")

    payload = verify_refresh_token(refresh_token)
    if not payload:
        raise api_response(401, "Invalid refresh token")
    user = decode_token(refresh_token)
    # user = UserRead.model_validate(db_user)
    access_token = create_access_token(user)
    new_refresh_token = create_access_token(user_data=user, refresh=True)

    return api_response(
        200,
        "Refresh",
        {
            "access_token": access_token,
            "refresh_token": new_refresh_token,
            **user,
        },
    )


@router.post("/logout")
def logout(response: Response):
    response.delete_cookie("refresh_token")
    response.delete_cookie("access_token")
    return {"message": "Logged out"}


# forgot otp password send
@router.post("/send-email")
def forgot_password(
    request: EmailRequest,
    session: GetSession,
):
    email = request.email.strip().lower()

    user = session.exec(select(User).where(User.email == email)).first()

    # ‚úÖ Do NOT reveal whether email exists (security best practice)
    if not user:
        return api_response(200, "If this email exists, an OTP has been sent.")

    # Generate 6-digit OTP
    otp = f"{randint(100000, 999999)}"
    user.otp_code = otp
    user.otp_expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)
    session.add(user)
    session.commit()

    # Send OTP via email or SMS
    send_email(
        to_email=user.email,
        subject="Your Password Reset OTP",
        body=f"Your OTP code is: {otp} (valid for 10 minutes)",
    )

    return api_response(200, "If this email exists, an OTP has been sent.")


@router.post("/reset-password")
def reset_password(
    request: ResetPasswordWithOTPRequest,
    session: GetSession,
):
    email = request.email.strip().lower()
    otp = request.otp.strip()
    new_password = request.new_password

    user = session.exec(select(User).where(User.email == email)).first()
    if not user:
        return api_response(400, "Invalid email or OTP")

    expires_at = user.otp_expires_at

    # üîê normalize legacy naive timestamps
    if expires_at.tzinfo is None:
        expires_at = expires_at.replace(tzinfo=timezone.utc)

    if user.otp_code != otp or expires_at < datetime.now(timezone.utc):
        return api_response(400, "Invalid or expired OTP")

    # Reset password
    user.password = hash_password(new_password)
    user.otp_code = None  # clear OTP
    user.otp_expires_at = None
    user.updated_at = datetime.now(timezone.utc)

    session.add(user)
    session.commit()

    return api_response(200, "Password has been reset successfully")


@router.get("/testauth", response_model=dict)
def test_auth(
    user: requireSignin,
):
    return api_response(
        200,
        "Token is valid",
        {"user": user},
    )


@router.get("/testadmin")
def get_admin_data(
    user: requireAdmin,
):

    return {"message": f"Hello Admin {user['phone']}", "user": user}


@router.get("/testpermission")
def get_admin_data(
    user=requirePermission("system:*"),
):
    return api_response(200, "Root Access Granted", {"user": user})
